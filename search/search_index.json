{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flex Config \u00b6 Configure your applications as easily as possible. Main Features \u00b6 Load config from wherever \u00b6 Comes with built in support for loading from dicts, environment variables, JSON/YAML/TOML files, and AWS SSM Parameter Store. Super easy to set up a custom source and load from anywhere. Type conversion, validation, and hints via Pydantic \u00b6 # \"ConfigSchema\" is pydantic's BaseModel renamed and re-exported for easier use from flex_config import ConfigSchema , construct_config class Config ( ConfigSchema ): a_string : str an_int : int # Raises ValidationError my_bad_config = construct_config ( Config , { \"a_string\" : [ \"not\" , \"a\" , \"string\" ], \"an_int\" : \"seven\" }) my_good_config = construct_config ( Config , { \"a_string\" : \"my_string\" , \"an_int\" : \"7\" }) assert isinstance ( my_good_config . an_int , int ) Dynamic loading of config values \u00b6 from pathlib import Path from typing import Dict , Any # \"ConfigSchema\" is pydantic's BaseModel renamed and re-exported for easier use from flex_config import ConfigSchema , construct_config , AWSSource , YAMLSource , EnvSource , ConfigSource class Config ( ConfigSchema ): env : str my_thing : str def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : # env is set to live or dev via environment variables in the deployment environment env = config_so_far . get ( \"env\" ) if env == \"local\" : # Not a live deployment, my_thing is in a local yaml file return {} return AWSSource ( f \"my_app/ { config_so_far [ 'env' ] } \" ) my_config = construct_config ( Config , [ EnvSource ( \"MY_APP_\" ), YAMLSource ( Path ( \"my_file.yaml\" )), get_ssm_params ]) Installation \u00b6 Basic install: poetry install flex_config With all optional dependencies (support for AWS SSM, YAML, and TOML): poetry install flex_config -E all For a full tutorial and API docs, check out the hosted documentation","title":"Intro"},{"location":"#flex-config","text":"Configure your applications as easily as possible.","title":"Flex Config"},{"location":"#main-features","text":"","title":"Main Features"},{"location":"#load-config-from-wherever","text":"Comes with built in support for loading from dicts, environment variables, JSON/YAML/TOML files, and AWS SSM Parameter Store. Super easy to set up a custom source and load from anywhere.","title":"Load config from wherever"},{"location":"#type-conversion-validation-and-hints-via-pydantic","text":"# \"ConfigSchema\" is pydantic's BaseModel renamed and re-exported for easier use from flex_config import ConfigSchema , construct_config class Config ( ConfigSchema ): a_string : str an_int : int # Raises ValidationError my_bad_config = construct_config ( Config , { \"a_string\" : [ \"not\" , \"a\" , \"string\" ], \"an_int\" : \"seven\" }) my_good_config = construct_config ( Config , { \"a_string\" : \"my_string\" , \"an_int\" : \"7\" }) assert isinstance ( my_good_config . an_int , int )","title":"Type conversion, validation, and hints via Pydantic"},{"location":"#dynamic-loading-of-config-values","text":"from pathlib import Path from typing import Dict , Any # \"ConfigSchema\" is pydantic's BaseModel renamed and re-exported for easier use from flex_config import ConfigSchema , construct_config , AWSSource , YAMLSource , EnvSource , ConfigSource class Config ( ConfigSchema ): env : str my_thing : str def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : # env is set to live or dev via environment variables in the deployment environment env = config_so_far . get ( \"env\" ) if env == \"local\" : # Not a live deployment, my_thing is in a local yaml file return {} return AWSSource ( f \"my_app/ { config_so_far [ 'env' ] } \" ) my_config = construct_config ( Config , [ EnvSource ( \"MY_APP_\" ), YAMLSource ( Path ( \"my_file.yaml\" )), get_ssm_params ])","title":"Dynamic loading of config values"},{"location":"#installation","text":"Basic install: poetry install flex_config With all optional dependencies (support for AWS SSM, YAML, and TOML): poetry install flex_config -E all For a full tutorial and API docs, check out the hosted documentation","title":"Installation"},{"location":"CHANGELOG/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 2.0.0 - unreleased \u00b6 Breaking Changes \u00b6 Complete rework of how FlexConfig works. Pydantic schemas are now used to define the shape and data in a config, but loading values from sources works the same way. Config values are now retrieved via dot notation ( my_config.section.value ) instead of the \"slash\" notation in 1.x ( my_config[\"section/value\"] ). See documentation for more info. Additions: \u00b6 Thanks to pydantic's built in data validation/conversion, the structure of the config and the types of it values are now strictly enforced so you can be sure that if your program starts without any validation errors the config is correctly built and all data types match what they are expected to be. Support for using a callable that takes in the compiled dictionary thus far and returns a ConfigSource as a source when constructing a config. Added support for TOML files and added explicit JSON support separate from YAMLSource that uses the builtin JSON module instead of relying on YAML's support for JSON. Config files that don't contain a top level dict (i.e. the top level structure is a list) will raise an error when being loaded. 1.0.0 - 2020-05-09 \u00b6 Initial release","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#200-unreleased","text":"","title":"2.0.0 - unreleased"},{"location":"CHANGELOG/#breaking-changes","text":"Complete rework of how FlexConfig works. Pydantic schemas are now used to define the shape and data in a config, but loading values from sources works the same way. Config values are now retrieved via dot notation ( my_config.section.value ) instead of the \"slash\" notation in 1.x ( my_config[\"section/value\"] ). See documentation for more info.","title":"Breaking Changes"},{"location":"CHANGELOG/#additions","text":"Thanks to pydantic's built in data validation/conversion, the structure of the config and the types of it values are now strictly enforced so you can be sure that if your program starts without any validation errors the config is correctly built and all data types match what they are expected to be. Support for using a callable that takes in the compiled dictionary thus far and returns a ConfigSource as a source when constructing a config. Added support for TOML files and added explicit JSON support separate from YAMLSource that uses the builtin JSON module instead of relying on YAML's support for JSON. Config files that don't contain a top level dict (i.e. the top level structure is a list) will raise an error when being loaded.","title":"Additions:"},{"location":"CHANGELOG/#100-2020-05-09","text":"Initial release","title":"1.0.0 - 2020-05-09"},{"location":"construct_config/","text":"\u00b6 Loads values from the sources passed in (in order) and creates an instance of the config schema specified. Parameters: Name Type Description Default config_schema Type[~ConfigClass] a subclass of ConfigSchema (or Pydantic's BaseModel) to validate config values with required sources Union[Sequence[Union[flex_config.config_source.ConfigSource, Callable[[Dict[str, Any]], flex_config.config_source.ConfigSource]]], flex_config.config_source.ConfigSource, Callable[[Dict[str, Any]], flex_config.config_source.ConfigSource]] A list of ConfigSources to be loaded and merged in the order they were passed in required Returns: Type Description ~ConfigClass An instance of the config schema passed in containing values loaded (in order) from the sources passed in Exceptions: Type Description TypeError If config_schema passed in is not a subclass of ConfigSchema (which is just a renamed and re-exported pydantic.BaseModel which you could subclass instead if you already have it imported) ValidationError If there are issues validating the compiled config values e.g. missing values or values that couldn't be converted to their specified type Source code in flex_config\\__init__.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def construct_config ( config_schema : Type [ ConfigClass ], sources : Union [ Sequence [ _SourceTypes ], _SourceTypes ] ) -> ConfigClass : \"\"\"Loads values from the sources passed in (in order) and creates an instance of the config schema specified. Args: config_schema: a subclass of ConfigSchema (or Pydantic's BaseModel) to validate config values with sources: A list of ConfigSources to be loaded and merged in the order they were passed in Returns: An instance of the config schema passed in containing values loaded (in order) from the sources passed in Raises: TypeError: If config_schema passed in is not a subclass of ConfigSchema (which is just a renamed and re-exported [pydantic.BaseModel](https://pydantic-docs.helpmanual.io/usage/models/#basic-model-usage) which you could subclass instead if you already have it imported) ValidationError: If there are issues validating the compiled config values e.g. missing values or values that couldn't be converted to their specified type \"\"\" if not issubclass ( config_schema , ConfigSchema ): raise TypeError ( \"Config schema supplied isn't a subclass of ConfigSchema (aka Pydantic's BaseModel)\" ) compiled_config_dict = _compile_sources ( sources = sources ) return cast ( ConfigClass , config_schema ( ** compiled_config_dict ))","title":"Construct config"},{"location":"construct_config/#flex_config.construct_config","text":"Loads values from the sources passed in (in order) and creates an instance of the config schema specified. Parameters: Name Type Description Default config_schema Type[~ConfigClass] a subclass of ConfigSchema (or Pydantic's BaseModel) to validate config values with required sources Union[Sequence[Union[flex_config.config_source.ConfigSource, Callable[[Dict[str, Any]], flex_config.config_source.ConfigSource]]], flex_config.config_source.ConfigSource, Callable[[Dict[str, Any]], flex_config.config_source.ConfigSource]] A list of ConfigSources to be loaded and merged in the order they were passed in required Returns: Type Description ~ConfigClass An instance of the config schema passed in containing values loaded (in order) from the sources passed in Exceptions: Type Description TypeError If config_schema passed in is not a subclass of ConfigSchema (which is just a renamed and re-exported pydantic.BaseModel which you could subclass instead if you already have it imported) ValidationError If there are issues validating the compiled config values e.g. missing values or values that couldn't be converted to their specified type Source code in flex_config\\__init__.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def construct_config ( config_schema : Type [ ConfigClass ], sources : Union [ Sequence [ _SourceTypes ], _SourceTypes ] ) -> ConfigClass : \"\"\"Loads values from the sources passed in (in order) and creates an instance of the config schema specified. Args: config_schema: a subclass of ConfigSchema (or Pydantic's BaseModel) to validate config values with sources: A list of ConfigSources to be loaded and merged in the order they were passed in Returns: An instance of the config schema passed in containing values loaded (in order) from the sources passed in Raises: TypeError: If config_schema passed in is not a subclass of ConfigSchema (which is just a renamed and re-exported [pydantic.BaseModel](https://pydantic-docs.helpmanual.io/usage/models/#basic-model-usage) which you could subclass instead if you already have it imported) ValidationError: If there are issues validating the compiled config values e.g. missing values or values that couldn't be converted to their specified type \"\"\" if not issubclass ( config_schema , ConfigSchema ): raise TypeError ( \"Config schema supplied isn't a subclass of ConfigSchema (aka Pydantic's BaseModel)\" ) compiled_config_dict = _compile_sources ( sources = sources ) return cast ( ConfigClass , config_schema ( ** compiled_config_dict ))","title":"flex_config.construct_config"},{"location":"tutorial/","text":"Tutorial \u00b6 We'll use a simplified version of the config.py included in our fastapi-serverless-cookiecutter for illustration. Warning In the below example we use all of the sources that come with flex_config. If you want to use all of them, you have to install optional dependencies. The easiest way is to poetry install flex_config -E all . If you only need specific sources (not all), then look at the API docs for that particular source to see what if any optional dependency you need. Creating a FlexConfig \u00b6 Everything is based around Pydantic's BaseModel , which we subclass and add fields to that are then populated from one or more ConfigSource s. Generally you want to create one of these and load its details only at startup, then reuse the same instance throughout the application. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config In the highlighted code, we: Import construct_config, ConfigSchema and the ConfigSource s that we want to use Declare a private global instance called _app_config , defaulting to None . Declare a function called get_config . This is how every other part of the app will get the config. Use the global _app_config locally in our function. Return the global _app_config if it's already been set. This prevents us re-loading the config. If _app_config hasn't been set up yet, we construct a brand new instance of our Config class via construct_config . Return our loaded up config object. Loading Sources \u00b6 A dict \u00b6 Now let's take a look at where we are loading the config from that ends up in _app_config . from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config We have some defaults set in the code itself. Here this is a simple dict which very intentionally conforms to the ConfigSource Protocol which is required for anything passed into construct_config . If you have a lot of defaults, you may want to use a YAMLSource instead. Sources passed into [load_sources] are loaded in order . So in our case, we pass in default_config first so that every source we load later overrides it. Environment Variables \u00b6 We're including an EnvSource to load values from environment variables. Usually, this source is used to load just enough info to be able to load from other sources. In the case of our serverless applications (where this was taken from), we load the \"env\" config value to tell us which environment this is running in (e.g. \"dev\"). You could load your entire application's config from EnvSource if you wanted to, say, load a bunch of stuff from AWS Secrets manager into environment variables at boot up. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config YAML (or JSON or TOML) Files \u00b6 Next up is a YAMLSource . Commonly we use this to store local config when developing since setting up environment variables or SSM config is cumbersome for values that may change frequently. The pattern shown is the same for a JSONSource or TOMLSource - a path to the respective type is passed in and the rest is handled for you. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config Overriding \u00b6 In this case, we're also allowing users to provide an \"override\" param which we will load last. This pattern makes testing and loading config for CLIs much easier. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config Dynamically loading sources \u00b6 Finally, we're going to advantage of the fact that we can pass in a callable that takes in the dictionry of compiled values so far and returns a ConfigSource . Our function checks which environment we're running in (based on the values loaded from the sources we've loaded so far). If we're not running locally, we return an [AWSSource] and load the rest of our config from AWS SSM. In this case, we've stored the values in SSM under the prefix \"app/env\" (e.g. \"app/dev\") though there is no limit to the length of the prefix nor the number of AWS sources you can load from. If we are running locally, get_ssm_params just returns an empty dictionary as there is nothing more to load. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"We'll use a simplified version of the config.py included in our fastapi-serverless-cookiecutter for illustration. Warning In the below example we use all of the sources that come with flex_config. If you want to use all of them, you have to install optional dependencies. The easiest way is to poetry install flex_config -E all . If you only need specific sources (not all), then look at the API docs for that particular source to see what if any optional dependency you need.","title":"Tutorial"},{"location":"tutorial/#creating-a-flexconfig","text":"Everything is based around Pydantic's BaseModel , which we subclass and add fields to that are then populated from one or more ConfigSource s. Generally you want to create one of these and load its details only at startup, then reuse the same instance throughout the application. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config In the highlighted code, we: Import construct_config, ConfigSchema and the ConfigSource s that we want to use Declare a private global instance called _app_config , defaulting to None . Declare a function called get_config . This is how every other part of the app will get the config. Use the global _app_config locally in our function. Return the global _app_config if it's already been set. This prevents us re-loading the config. If _app_config hasn't been set up yet, we construct a brand new instance of our Config class via construct_config . Return our loaded up config object.","title":"Creating a FlexConfig"},{"location":"tutorial/#loading-sources","text":"","title":"Loading Sources"},{"location":"tutorial/#a-dict","text":"Now let's take a look at where we are loading the config from that ends up in _app_config . from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config We have some defaults set in the code itself. Here this is a simple dict which very intentionally conforms to the ConfigSource Protocol which is required for anything passed into construct_config . If you have a lot of defaults, you may want to use a YAMLSource instead. Sources passed into [load_sources] are loaded in order . So in our case, we pass in default_config first so that every source we load later overrides it.","title":"A dict"},{"location":"tutorial/#environment-variables","text":"We're including an EnvSource to load values from environment variables. Usually, this source is used to load just enough info to be able to load from other sources. In the case of our serverless applications (where this was taken from), we load the \"env\" config value to tell us which environment this is running in (e.g. \"dev\"). You could load your entire application's config from EnvSource if you wanted to, say, load a bunch of stuff from AWS Secrets manager into environment variables at boot up. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config","title":"Environment Variables"},{"location":"tutorial/#yaml-or-json-or-toml-files","text":"Next up is a YAMLSource . Commonly we use this to store local config when developing since setting up environment variables or SSM config is cumbersome for values that may change frequently. The pattern shown is the same for a JSONSource or TOMLSource - a path to the respective type is passed in and the rest is handled for you. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config","title":"YAML (or JSON or TOML) Files"},{"location":"tutorial/#overriding","text":"In this case, we're also allowing users to provide an \"override\" param which we will load last. This pattern makes testing and loading config for CLIs much easier. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config","title":"Overriding"},{"location":"tutorial/#dynamically-loading-sources","text":"Finally, we're going to advantage of the fact that we can pass in a callable that takes in the dictionry of compiled values so far and returns a ConfigSource . Our function checks which environment we're running in (based on the values loaded from the sources we've loaded so far). If we're not running locally, we return an [AWSSource] and load the rest of our config from AWS SSM. In this case, we've stored the values in SSM under the prefix \"app/env\" (e.g. \"app/dev\") though there is no limit to the length of the prefix nor the number of AWS sources you can load from. If we are running locally, get_ssm_params just returns an empty dictionary as there is nothing more to load. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , ConfigSchema , ConfigSource , EnvSource , YAMLSource , construct_config class DataBaseConfig ( ConfigSchema ): url : str username : str password : str class SentryConfig ( ConfigSchema ): url : str traces_sample_rate : float = 0.1 class Config ( ConfigSchema ): env : str special_number : int database : DataBaseConfig sentry : SentryConfig def get_ssm_params ( config_so_far : Dict [ str , Any ]) -> ConfigSource : env = config_so_far . get ( \"env\" ) if env == \"local\" : return {} return AWSSource ( f \"my_app/ { env } \" ) default_config = { \"env\" : \"local\" , } _app_config : Optional [ Config ] = None yaml_path = Path . cwd () / \"config.yml\" def get_config ( override : Dict [ str , Any ] = None ) -> Config : \"\"\" Get the app config for this app \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = construct_config ( config_schema = Config , sources = [ default_config , EnvSource ( \"CAT_\" ), YAMLSource ( yaml_path ), get_ssm_params , override , ], ) return _app_config","title":"Dynamically loading sources"},{"location":"ConfigSources/aws_source/","text":"\u00b6 A ConfigSource that loads values recursively from an AWS SSM path. Warning In order to use this source you must have boto3 installed either directly or by including the \"aws\" extra when installing this package (e.g. poetry install flex-config -E aws ). Parameters: Name Type Description Default path str a prefix in AWS SSM to read from. required Info You can pass any keyword arguments to this class that you would to boto3 directly (e.g. secret key). items ( self ) \u00b6 Returns a generator for getting all path, value pairs Source code in flex_config\\aws_source.py 62 63 64 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" return self . to_dict () . items () to_dict ( self ) \u00b6 Returns a generator for getting all path, value pairs Source code in flex_config\\aws_source.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" kwargs : Dict [ str , Any ] = {} param_dict : Dict [ str , Any ] = {} while True : result = self . ssm . get_parameters_by_path ( Path = f \"/ { self . path } /\" , Recursive = True , WithDecryption = True , ** kwargs ) for param in result [ \"Parameters\" ]: path = param [ \"Name\" ] . replace ( f \"/ { self . path } /\" , \"\" ) # Don't repeat SSM path in key param_dict = insert_value_at_nested_key ( dest_dict = param_dict , subkey_path = path . split ( \"/\" ), value = param [ \"Value\" ] ) kwargs [ \"NextToken\" ] = result . get ( \"NextToken\" ) if kwargs [ \"NextToken\" ] is None : # That's the last of the values break return param_dict","title":"AWSSource"},{"location":"ConfigSources/aws_source/#flex_config.aws_source.AWSSource","text":"A ConfigSource that loads values recursively from an AWS SSM path. Warning In order to use this source you must have boto3 installed either directly or by including the \"aws\" extra when installing this package (e.g. poetry install flex-config -E aws ). Parameters: Name Type Description Default path str a prefix in AWS SSM to read from. required Info You can pass any keyword arguments to this class that you would to boto3 directly (e.g. secret key).","title":"flex_config.aws_source.AWSSource"},{"location":"ConfigSources/aws_source/#flex_config.aws_source.AWSSource.items","text":"Returns a generator for getting all path, value pairs Source code in flex_config\\aws_source.py 62 63 64 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" return self . to_dict () . items ()","title":"items()"},{"location":"ConfigSources/aws_source/#flex_config.aws_source.AWSSource.to_dict","text":"Returns a generator for getting all path, value pairs Source code in flex_config\\aws_source.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" kwargs : Dict [ str , Any ] = {} param_dict : Dict [ str , Any ] = {} while True : result = self . ssm . get_parameters_by_path ( Path = f \"/ { self . path } /\" , Recursive = True , WithDecryption = True , ** kwargs ) for param in result [ \"Parameters\" ]: path = param [ \"Name\" ] . replace ( f \"/ { self . path } /\" , \"\" ) # Don't repeat SSM path in key param_dict = insert_value_at_nested_key ( dest_dict = param_dict , subkey_path = path . split ( \"/\" ), value = param [ \"Value\" ] ) kwargs [ \"NextToken\" ] = result . get ( \"NextToken\" ) if kwargs [ \"NextToken\" ] is None : # That's the last of the values break return param_dict","title":"to_dict()"},{"location":"ConfigSources/config_source/","text":"\u00b6 The protocol required to be used as a source of values in a FlexConfig This is very much intended to support builtin `dict` as a source . items ( self ) \u00b6 A function to getting key, value pairs to store in the FlexConfig Source code in flex_config\\config_source.py 10 11 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" A function to getting key, value pairs to store in the FlexConfig \"\"\"","title":"ConfigSource"},{"location":"ConfigSources/config_source/#flex_config.config_source.ConfigSource","text":"The protocol required to be used as a source of values in a FlexConfig This is very much intended to support builtin `dict` as a source .","title":"flex_config.config_source.ConfigSource"},{"location":"ConfigSources/config_source/#flex_config.config_source.ConfigSource.items","text":"A function to getting key, value pairs to store in the FlexConfig Source code in flex_config\\config_source.py 10 11 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" A function to getting key, value pairs to store in the FlexConfig \"\"\"","title":"items()"},{"location":"ConfigSources/env_source/","text":"\u00b6 A ConfigSource that loads values from environment variables. Parameters: Name Type Description Default prefix str a prefix for all environment variables that should be loaded (e.g. \"APP_\"). Only vars which begin with the prefix will be loaded. required separator str a string that will separate nested values. Defaults to . required Note All keys will be converted to lower case with the prefix stripped. items ( self ) \u00b6 Returns a generator for getting all key, value pairs Source code in flex_config\\env_source.py 52 53 54 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" Returns a generator for getting all key, value pairs \"\"\" return self . to_dict () . items () to_dict ( self ) \u00b6 Returns a generator for getting all key, value pairs Source code in flex_config\\env_source.py 40 41 42 43 44 45 46 47 48 49 50 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Returns a generator for getting all key, value pairs \"\"\" param_dict : Dict [ str , Any ] = {} for key , value in os . environ . items (): if not key . startswith ( self . prefix ): continue key = key . replace ( self . prefix , \"\" ) param_dict = insert_value_at_nested_key ( dest_dict = param_dict , subkey_path = key . split ( self . separator ), value = value ) return param_dict","title":"EnvSource"},{"location":"ConfigSources/env_source/#flex_config.env_source.EnvSource","text":"A ConfigSource that loads values from environment variables. Parameters: Name Type Description Default prefix str a prefix for all environment variables that should be loaded (e.g. \"APP_\"). Only vars which begin with the prefix will be loaded. required separator str a string that will separate nested values. Defaults to . required Note All keys will be converted to lower case with the prefix stripped.","title":"flex_config.env_source.EnvSource"},{"location":"ConfigSources/env_source/#flex_config.env_source.EnvSource.items","text":"Returns a generator for getting all key, value pairs Source code in flex_config\\env_source.py 52 53 54 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" Returns a generator for getting all key, value pairs \"\"\" return self . to_dict () . items ()","title":"items()"},{"location":"ConfigSources/env_source/#flex_config.env_source.EnvSource.to_dict","text":"Returns a generator for getting all key, value pairs Source code in flex_config\\env_source.py 40 41 42 43 44 45 46 47 48 49 50 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\" Returns a generator for getting all key, value pairs \"\"\" param_dict : Dict [ str , Any ] = {} for key , value in os . environ . items (): if not key . startswith ( self . prefix ): continue key = key . replace ( self . prefix , \"\" ) param_dict = insert_value_at_nested_key ( dest_dict = param_dict , subkey_path = key . split ( self . separator ), value = value ) return param_dict","title":"to_dict()"},{"location":"ConfigSources/FileSources/json_source/","text":"\u00b6 A ConfigSource that loads values from a JSON file. Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a json file to load. required path_must_exist bool if true, the constructor will raise a RuntimeError if the provided path doesn't exist. required _load_file ( self , file ) private \u00b6 Loads and parses the json file Source code in flex_config\\file_sources\\json_source.py 29 30 31 32 33 34 def _load_file ( self , file : TextIO ) -> Dict [ str , Any ]: \"\"\" Loads and parses the json file \"\"\" import json config_dict = json . load ( file ) return config_dict","title":"JSONSource"},{"location":"ConfigSources/FileSources/json_source/#flex_config.file_sources.json_source.JSONSource","text":"A ConfigSource that loads values from a JSON file. Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a json file to load. required path_must_exist bool if true, the constructor will raise a RuntimeError if the provided path doesn't exist. required","title":"flex_config.file_sources.json_source.JSONSource"},{"location":"ConfigSources/FileSources/json_source/#flex_config.file_sources.json_source.JSONSource._load_file","text":"Loads and parses the json file Source code in flex_config\\file_sources\\json_source.py 29 30 31 32 33 34 def _load_file ( self , file : TextIO ) -> Dict [ str , Any ]: \"\"\" Loads and parses the json file \"\"\" import json config_dict = json . load ( file ) return config_dict","title":"_load_file()"},{"location":"ConfigSources/FileSources/toml_source/","text":"\u00b6 A ConfigSource that loads values from a TOML file. Warning In order to use this source you must have toml installed either directly or by including the \"toml\" extra when installing this package (e.g. poetry install flex-config -E toml ). Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a TOML file to load. required path_must_exist bool if true, the constructor will raise a RuntimeError if the provided path doesn't exist. required _load_file ( self , file ) private \u00b6 Loads and parses the TOML file Source code in flex_config\\file_sources\\toml_source.py 35 36 37 38 39 40 def _load_file ( self , file : TextIO ) -> Dict [ str , Any ]: \"\"\" Loads and parses the TOML file \"\"\" import toml config_dict = toml . load ( file ) return cast ( Dict [ str , Any ], config_dict )","title":"TOMLSource"},{"location":"ConfigSources/FileSources/toml_source/#flex_config.file_sources.toml_source.TOMLSource","text":"A ConfigSource that loads values from a TOML file. Warning In order to use this source you must have toml installed either directly or by including the \"toml\" extra when installing this package (e.g. poetry install flex-config -E toml ). Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a TOML file to load. required path_must_exist bool if true, the constructor will raise a RuntimeError if the provided path doesn't exist. required","title":"flex_config.file_sources.toml_source.TOMLSource"},{"location":"ConfigSources/FileSources/toml_source/#flex_config.file_sources.toml_source.TOMLSource._load_file","text":"Loads and parses the TOML file Source code in flex_config\\file_sources\\toml_source.py 35 36 37 38 39 40 def _load_file ( self , file : TextIO ) -> Dict [ str , Any ]: \"\"\" Loads and parses the TOML file \"\"\" import toml config_dict = toml . load ( file ) return cast ( Dict [ str , Any ], config_dict )","title":"_load_file()"},{"location":"ConfigSources/FileSources/yaml_source/","text":"\u00b6 A ConfigSource that loads values from a YAML file. Warning In order to use this source you must have pyyaml installed either directly or by including the \"yaml\" extra when installing this package (e.g. poetry install flex-config -E yaml ). Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a YAML file to load. required path_must_exist bool if true, the constructor will raise a RuntimeError if the provided path doesn't exist. required _load_file ( self , file ) private \u00b6 Loads and parses the YAML file Source code in flex_config\\file_sources\\yaml_source.py 34 35 36 37 38 39 def _load_file ( self , file : TextIO ) -> Dict [ str , Any ]: \"\"\" Loads and parses the YAML file \"\"\" import yaml config_dict = yaml . safe_load ( file ) return config_dict","title":"YAMLSource"},{"location":"ConfigSources/FileSources/yaml_source/#flex_config.file_sources.yaml_source.YAMLSource","text":"A ConfigSource that loads values from a YAML file. Warning In order to use this source you must have pyyaml installed either directly or by including the \"yaml\" extra when installing this package (e.g. poetry install flex-config -E yaml ). Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a YAML file to load. required path_must_exist bool if true, the constructor will raise a RuntimeError if the provided path doesn't exist. required","title":"flex_config.file_sources.yaml_source.YAMLSource"},{"location":"ConfigSources/FileSources/yaml_source/#flex_config.file_sources.yaml_source.YAMLSource._load_file","text":"Loads and parses the YAML file Source code in flex_config\\file_sources\\yaml_source.py 34 35 36 37 38 39 def _load_file ( self , file : TextIO ) -> Dict [ str , Any ]: \"\"\" Loads and parses the YAML file \"\"\" import yaml config_dict = yaml . safe_load ( file ) return config_dict","title":"_load_file()"}]}