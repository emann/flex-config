{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flex Config \u00b6 If you are not reading this from the hosted documentation I recommend you switch over to that for the best viewing experience. FlexConfig is designed specifically to make configuring web apps as easy as possible on AWS. A similar pattern is followed whether deploying to EC2, ECS, or Lambda. Ultimately, FlexConfig is a glorified dict that makes loading from multiple sources easy, and provides some simple path-like lookup features. from flex_config import FlexConfig flex_config = FlexConfig () # In FlexConfig, these two are equivalent flex_config [ \"app\" ][ \"env\" ] == flex_config [ \"app/env\" ] Installation \u00b6 Basic install: poetry install flex_config With all optional dependencies: poetry install flex_config -E all Walkthrough \u00b6 We'll use a simplified version of the config.py included in our fastapi-serverless-cookiecutter for illustration. Everything is based around the FlexConfig class, that is what will store all of your config. Generally you want to create one of these and load its details only at startup, then reuse the same instance throughout the application. Warning In the below example we use all of the sources that come with flex_config. If you want to use all of them, you have to install optional dependencies. The easiest way is to poetry install flex_config -E all . If you only need specific sources (not all), then look at the API docs for that particular source to see what if any optional dependency you need. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config In the highlighted code, we: import FlexConfig Declare a private global instance called _app_config , defaulting to None . Declare a function called get_config . This is how every other part of the app will get the config. Use the global _app_config locally in our function. Return the global _app_config if it's already been set. This prevents us re-loading the config. If _app_config hasn't been set up yet, we set it to a brand new FlexConfig . Return our loaded up config object. Now let's take a look at where we are loading the config from that ends up in _app_config . from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config We have some defaults set in the code itself. Here this is a simple dict which very intentionally conforms to the ConfigSource Protocol which is required for anything passed into load_sources . If you have a lot of defaults, you may want to use a YAMLSource instead. Sources passed into load_sources are loaded in order . So in our case, we pass in default_config first so that every source we load later overrides it. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config Next, we're including an EnvSource to load values from environment variables. Usually, this source is used to load just enough info to be able to load from other sources. In the case of our serverless applications (where this was taken from), we load the \"env\" config value to tell us which environment this is running in (e.g. \"dev\"). You could load your entire application's config from EnvSource if you wanted to, say, load a bunch of stuff from AWS Secrets manager into environment variables at boot up. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config Next up is a YAMLSource . Commonly we use this to store local config when developing since setting up environment variables or SSM config is cumbersome for values that may change frequently. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config In this case, we're also allowing users to provide an \"override\" param which we will load last. This pattern makes testing and loading config for CLIs much easier. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config Finally, we're going to check which environment we're running in (loaded by all the previous sources). If we're not running locally, we load the rest of our config from AWS SSM. In this case, we've stored that info under the prefix \"app/env\" (e.g. \"app/dev\") though there is no limit to the length of the prefix nor the number of AWS sources you can load from.","title":"Tutorial"},{"location":"#flex-config","text":"If you are not reading this from the hosted documentation I recommend you switch over to that for the best viewing experience. FlexConfig is designed specifically to make configuring web apps as easy as possible on AWS. A similar pattern is followed whether deploying to EC2, ECS, or Lambda. Ultimately, FlexConfig is a glorified dict that makes loading from multiple sources easy, and provides some simple path-like lookup features. from flex_config import FlexConfig flex_config = FlexConfig () # In FlexConfig, these two are equivalent flex_config [ \"app\" ][ \"env\" ] == flex_config [ \"app/env\" ]","title":"Flex Config"},{"location":"#installation","text":"Basic install: poetry install flex_config With all optional dependencies: poetry install flex_config -E all","title":"Installation"},{"location":"#walkthrough","text":"We'll use a simplified version of the config.py included in our fastapi-serverless-cookiecutter for illustration. Everything is based around the FlexConfig class, that is what will store all of your config. Generally you want to create one of these and load its details only at startup, then reuse the same instance throughout the application. Warning In the below example we use all of the sources that come with flex_config. If you want to use all of them, you have to install optional dependencies. The easiest way is to poetry install flex_config -E all . If you only need specific sources (not all), then look at the API docs for that particular source to see what if any optional dependency you need. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config In the highlighted code, we: import FlexConfig Declare a private global instance called _app_config , defaulting to None . Declare a function called get_config . This is how every other part of the app will get the config. Use the global _app_config locally in our function. Return the global _app_config if it's already been set. This prevents us re-loading the config. If _app_config hasn't been set up yet, we set it to a brand new FlexConfig . Return our loaded up config object. Now let's take a look at where we are loading the config from that ends up in _app_config . from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config We have some defaults set in the code itself. Here this is a simple dict which very intentionally conforms to the ConfigSource Protocol which is required for anything passed into load_sources . If you have a lot of defaults, you may want to use a YAMLSource instead. Sources passed into load_sources are loaded in order . So in our case, we pass in default_config first so that every source we load later overrides it. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config Next, we're including an EnvSource to load values from environment variables. Usually, this source is used to load just enough info to be able to load from other sources. In the case of our serverless applications (where this was taken from), we load the \"env\" config value to tell us which environment this is running in (e.g. \"dev\"). You could load your entire application's config from EnvSource if you wanted to, say, load a bunch of stuff from AWS Secrets manager into environment variables at boot up. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config Next up is a YAMLSource . Commonly we use this to store local config when developing since setting up environment variables or SSM config is cumbersome for values that may change frequently. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config In this case, we're also allowing users to provide an \"override\" param which we will load last. This pattern makes testing and loading config for CLIs much easier. from pathlib import Path from typing import Any , Dict , Optional from flex_config import AWSSource , EnvSource , FlexConfig , YAMLSource _app_config : Optional [ FlexConfig ] = None yaml_path = Path . cwd () / \"config.yml\" default_config = { \"env\" : \"local\" , } def get_config ( override : Dict [ str , Any ] = None ) -> FlexConfig : \"\"\" Get the app config for this \"\"\" global _app_config if _app_config : return _app_config if not override : override = {} _app_config = FlexConfig () _app_config . load_sources ([ default_config , EnvSource ( \"APP_\" ), YAMLSource ( yaml_path ), override , ]) env = _app_config [ \"env\" ] if env != \"local\" : _app_config . load_sources ( AWSSource ( f \"app/ { env } \" )) return _app_config Finally, we're going to check which environment we're running in (loaded by all the previous sources). If we're not running locally, we load the rest of our config from AWS SSM. In this case, we've stored that info under the prefix \"app/env\" (e.g. \"app/dev\") though there is no limit to the length of the prefix nor the number of AWS sources you can load from.","title":"Walkthrough"},{"location":"CHANGELOG/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 1.0.0 - 2020-05-03 \u00b6 Initial release","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#100-2020-05-03","text":"Initial release","title":"1.0.0 - 2020-05-03"},{"location":"api/aws_source/","text":"\u00b6 A ConfigSource that loads values recursively from an AWS SSM path. Warning In order to use this source you must have boto3 installed either directly or by including the \"aws\" extra when installing this package (e.g. poetry install flex-config -E aws ). Parameters: Name Type Description Default path str a prefix in AWS SSM to read from. required Info You can pass any keyword arguments to this class that you would to boto3 directly (e.g. secret key). Example from flex_config import AWSSource , FlexConfig aws_source = AWSSource ( f \"my_app/dev\" ) my_config = FlexConfig () my_config . load_sources ( aws_source ) items ( self ) \u00b6 Returns a generator for getting all path, value pairs Source code in flex_config/aws_source.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def items ( self ) -> Generator [ Tuple [ str , Any ], None , None ]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" kwargs : Dict [ str , Any ] = {} while True : result = self . ssm . get_parameters_by_path ( Path = f \"/ { self . path } /\" , Recursive = True , WithDecryption = True , ** kwargs ) for param in result [ \"Parameters\" ]: key = param [ \"Name\" ] . replace ( f \"/ { self . path } /\" , \"\" ) # Don't repeat SSM path in key yield key , param [ \"Value\" ] kwargs [ \"NextToken\" ] = result . get ( \"NextToken\" ) if kwargs [ \"NextToken\" ] is None : # That's the last of the values break","title":"AWSSource"},{"location":"api/aws_source/#flex_config.aws_source.AWSSource","text":"A ConfigSource that loads values recursively from an AWS SSM path. Warning In order to use this source you must have boto3 installed either directly or by including the \"aws\" extra when installing this package (e.g. poetry install flex-config -E aws ). Parameters: Name Type Description Default path str a prefix in AWS SSM to read from. required Info You can pass any keyword arguments to this class that you would to boto3 directly (e.g. secret key). Example from flex_config import AWSSource , FlexConfig aws_source = AWSSource ( f \"my_app/dev\" ) my_config = FlexConfig () my_config . load_sources ( aws_source )","title":"flex_config.aws_source.AWSSource"},{"location":"api/aws_source/#flex_config.aws_source.AWSSource.items","text":"Returns a generator for getting all path, value pairs Source code in flex_config/aws_source.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def items ( self ) -> Generator [ Tuple [ str , Any ], None , None ]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" kwargs : Dict [ str , Any ] = {} while True : result = self . ssm . get_parameters_by_path ( Path = f \"/ { self . path } /\" , Recursive = True , WithDecryption = True , ** kwargs ) for param in result [ \"Parameters\" ]: key = param [ \"Name\" ] . replace ( f \"/ { self . path } /\" , \"\" ) # Don't repeat SSM path in key yield key , param [ \"Value\" ] kwargs [ \"NextToken\" ] = result . get ( \"NextToken\" ) if kwargs [ \"NextToken\" ] is None : # That's the last of the values break","title":"items()"},{"location":"api/config_source/","text":"\u00b6 The protocol required to be used as a source of values in a FlexConfig This is very much intended to support builtin dict as a source. items ( self ) \u00b6 A function to getting key, value pairs to store in the FlexConfig Source code in flex_config/config_source.py 10 11 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" A function to getting key, value pairs to store in the FlexConfig \"\"\"","title":"ConfigSource"},{"location":"api/config_source/#flex_config.config_source.ConfigSource","text":"The protocol required to be used as a source of values in a FlexConfig This is very much intended to support builtin dict as a source.","title":"flex_config.config_source.ConfigSource"},{"location":"api/config_source/#flex_config.config_source.ConfigSource.items","text":"A function to getting key, value pairs to store in the FlexConfig Source code in flex_config/config_source.py 10 11 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" A function to getting key, value pairs to store in the FlexConfig \"\"\"","title":"items()"},{"location":"api/env_source/","text":"\u00b6 A ConfigSource that loads values from environment variables. Parameters: Name Type Description Default prefix str a prefix for all environment variables that should be loaded (e.g. \"APP_\"). Only vars which begin with the prefix will be loaded. required separator str a string that will separate nested values. Defaults to . required Note All keys will be converted to lower case with the prefix stripped. Example from flex_config import EnvSource , FlexConfig # Say you have APP_ENV and APP_DATABASE.URL as environment variables env_source = EnvSource ( \"APP_\" ) my_config = FlexConfig () my_config . load_sources ( env_source ) assert \"env\" in my_config assert \"database\" in my_config assert \"url\" in my_config [ \"database\" ] items ( self ) \u00b6 Returns a generator for getting all path, value pairs Source code in flex_config/env_source.py 38 39 40 41 42 43 44 def items ( self ) -> Generator [ Tuple [ str , Any ], None , None ]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" for key , value in os . environ . items (): if not key . startswith ( self . prefix ): continue key = key . replace ( self . prefix , \"\" ) . replace ( self . separator , \"/\" ) . lower () yield key , value","title":"EnvSource"},{"location":"api/env_source/#flex_config.env_source.EnvSource","text":"A ConfigSource that loads values from environment variables. Parameters: Name Type Description Default prefix str a prefix for all environment variables that should be loaded (e.g. \"APP_\"). Only vars which begin with the prefix will be loaded. required separator str a string that will separate nested values. Defaults to . required Note All keys will be converted to lower case with the prefix stripped. Example from flex_config import EnvSource , FlexConfig # Say you have APP_ENV and APP_DATABASE.URL as environment variables env_source = EnvSource ( \"APP_\" ) my_config = FlexConfig () my_config . load_sources ( env_source ) assert \"env\" in my_config assert \"database\" in my_config assert \"url\" in my_config [ \"database\" ]","title":"flex_config.env_source.EnvSource"},{"location":"api/env_source/#flex_config.env_source.EnvSource.items","text":"Returns a generator for getting all path, value pairs Source code in flex_config/env_source.py 38 39 40 41 42 43 44 def items ( self ) -> Generator [ Tuple [ str , Any ], None , None ]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" for key , value in os . environ . items (): if not key . startswith ( self . prefix ): continue key = key . replace ( self . prefix , \"\" ) . replace ( self . separator , \"/\" ) . lower () yield key , value","title":"items()"},{"location":"api/flex_config/","text":"\u00b6 Holds config values which can be loaded from many sources flatten_dict ( d ) staticmethod \u00b6 Takes a dict with potentially nested values and returns a flat dict Returns: Type Description Dict[str, Any] Flattened dictionary Source code in flex_config/__init__.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @staticmethod def flatten_dict ( d : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Takes a dict with potentially nested values and returns a flat dict Returns: Flattened dictionary \"\"\" keys = list ( d . keys ()) # can't be an iterator because we're modifying in this loop for key in keys : if isinstance ( d [ key ], dict ): # This is a dict within the top level dict d [ key ] = FlexConfig . flatten_dict ( d [ key ]) # First flatten the internal dict for inner_key , inner_value in d [ key ] . items (): # Now pull all of its keys into the top level dict d [ f \" { key } / { inner_key } \" ] = inner_value del d [ key ] return d get ( self , item , default = None ) \u00b6 Get a value if it exists, if not return None Source code in flex_config/__init__.py 89 90 91 92 93 94 def get ( self , item : str , default : Any = None ) -> Any : \"\"\" Get a value if it exists, if not return None \"\"\" try : return self [ item ] except KeyError : return default load_sources ( self , config_sources ) \u00b6 Load the data from a [ConfigSource][flex_config.config_source.ConfigSource] or list thereof Parameters: Name Type Description Default config_sources Union[Sequence[flex_config.config_source.ConfigSource], flex_config.config_source.ConfigSource] A Single or ConfigSource or Iterable of ConfigSources. required Source code in flex_config/__init__.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def load_sources ( self , config_sources : Union [ Sequence [ ConfigSource ], ConfigSource ]) -> None : \"\"\" Load the data from a [ConfigSource][flex_config.config_source.ConfigSource] or list thereof Args: config_sources: A Single or ConfigSource or Iterable of ConfigSources. \"\"\" if not isinstance ( config_sources , Sequence ): config_sources = [ config_sources ] for source in config_sources : for ( path , value ) in source . items (): self [ path ] = value validate ( self ) \u00b6 Verify that all required attributes are set Exceptions: Type Description KeyError If any required attribute is missing Source code in flex_config/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 def validate ( self ) -> None : \"\"\" Verify that all required attributes are set Raises: KeyError: If any required attribute is missing \"\"\" if self . required is None : return for attr in self . required : # noinspection PyStatementEffect self [ attr ]","title":"FlexConfig"},{"location":"api/flex_config/#flex_config.FlexConfig","text":"Holds config values which can be loaded from many sources","title":"flex_config.FlexConfig"},{"location":"api/flex_config/#flex_config.FlexConfig.flatten_dict","text":"Takes a dict with potentially nested values and returns a flat dict Returns: Type Description Dict[str, Any] Flattened dictionary Source code in flex_config/__init__.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @staticmethod def flatten_dict ( d : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\" Takes a dict with potentially nested values and returns a flat dict Returns: Flattened dictionary \"\"\" keys = list ( d . keys ()) # can't be an iterator because we're modifying in this loop for key in keys : if isinstance ( d [ key ], dict ): # This is a dict within the top level dict d [ key ] = FlexConfig . flatten_dict ( d [ key ]) # First flatten the internal dict for inner_key , inner_value in d [ key ] . items (): # Now pull all of its keys into the top level dict d [ f \" { key } / { inner_key } \" ] = inner_value del d [ key ] return d","title":"flatten_dict()"},{"location":"api/flex_config/#flex_config.FlexConfig.get","text":"Get a value if it exists, if not return None Source code in flex_config/__init__.py 89 90 91 92 93 94 def get ( self , item : str , default : Any = None ) -> Any : \"\"\" Get a value if it exists, if not return None \"\"\" try : return self [ item ] except KeyError : return default","title":"get()"},{"location":"api/flex_config/#flex_config.FlexConfig.load_sources","text":"Load the data from a [ConfigSource][flex_config.config_source.ConfigSource] or list thereof Parameters: Name Type Description Default config_sources Union[Sequence[flex_config.config_source.ConfigSource], flex_config.config_source.ConfigSource] A Single or ConfigSource or Iterable of ConfigSources. required Source code in flex_config/__init__.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def load_sources ( self , config_sources : Union [ Sequence [ ConfigSource ], ConfigSource ]) -> None : \"\"\" Load the data from a [ConfigSource][flex_config.config_source.ConfigSource] or list thereof Args: config_sources: A Single or ConfigSource or Iterable of ConfigSources. \"\"\" if not isinstance ( config_sources , Sequence ): config_sources = [ config_sources ] for source in config_sources : for ( path , value ) in source . items (): self [ path ] = value","title":"load_sources()"},{"location":"api/flex_config/#flex_config.FlexConfig.validate","text":"Verify that all required attributes are set Exceptions: Type Description KeyError If any required attribute is missing Source code in flex_config/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 def validate ( self ) -> None : \"\"\" Verify that all required attributes are set Raises: KeyError: If any required attribute is missing \"\"\" if self . required is None : return for attr in self . required : # noinspection PyStatementEffect self [ attr ]","title":"validate()"},{"location":"api/yaml_source/","text":"\u00b6 A ConfigSource that loads values from a YAML file. Warning In order to use this source you must have pyyaml installed either directly or by including the \"yaml\" extra when installing this package (e.g. poetry install flex-config -E yaml ). Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a YAML file to load. required Example from pathlib import Path from flex_config import FlexConfig , YAMLSource my_yaml_file = Path ( \"path/to/my.yaml\" ) yaml_source = YAMLSource ( my_yaml_file ) my_config = FlexConfig () my_config . load_sources ( yaml_source ) items ( self ) \u00b6 Returns a generator for getting all path, value pairs Source code in flex_config/yaml_source.py 37 38 39 40 41 42 43 44 45 46 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" import yaml if not self . path . exists (): return [] with self . path . open () as config_yml_file : config_dict = yaml . safe_load ( config_yml_file ) return config_dict . items ()","title":"YAMLSource"},{"location":"api/yaml_source/#flex_config.yaml_source.YAMLSource","text":"A ConfigSource that loads values from a YAML file. Warning In order to use this source you must have pyyaml installed either directly or by including the \"yaml\" extra when installing this package (e.g. poetry install flex-config -E yaml ). Parameters: Name Type Description Default path pathlib.Path a pathlib.Path to a YAML file to load. required Example from pathlib import Path from flex_config import FlexConfig , YAMLSource my_yaml_file = Path ( \"path/to/my.yaml\" ) yaml_source = YAMLSource ( my_yaml_file ) my_config = FlexConfig () my_config . load_sources ( yaml_source )","title":"flex_config.yaml_source.YAMLSource"},{"location":"api/yaml_source/#flex_config.yaml_source.YAMLSource.items","text":"Returns a generator for getting all path, value pairs Source code in flex_config/yaml_source.py 37 38 39 40 41 42 43 44 45 46 def items ( self ) -> Iterable [ Tuple [ str , Any ]]: \"\"\" Returns a generator for getting all path, value pairs \"\"\" import yaml if not self . path . exists (): return [] with self . path . open () as config_yml_file : config_dict = yaml . safe_load ( config_yml_file ) return config_dict . items ()","title":"items()"}]}